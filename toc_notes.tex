\documentclass[12pt]{article}

\usepackage{fouriernc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage[margin=0.5in]{geometry}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\newcommand{\curly}[1]{\left\{ #1 \right\}}
\newcommand{\round}[1]{\left( #1 \right)}
\newcommand{\hard}[1]{\left[ #1 \right]}
\newcommand{\C}[2]{
    \begin{pmatrix}
        #1 \\ #2
    \end{pmatrix}
}

\title{Theory of Computing Notes}
\author{Tim Harding}

\begin{document}

\begin{center}
    \begin{tabular}{|l|l|l|}
        \hline
        Regular & Finite automaton & Regular expressions \\ \hline
        Context-Free & Pushdown automaton & Grammar \\ \hline
        Decidable & Turing machine & Code \\ \hline
    \end{tabular}
\end{center}

\section*{Regular}
Finite automata can be expressed the following ways:
\begin{enumerate}
    \item A transition table, with states on one axis and alphabet characters on the other
    \item A graph with states as nodes, transitions on alphabet characters as edges, and acceptance states specially demarcated
    \item A regular expression
\end{enumerate}

\subsection*{Regular Operations}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Union & $A \cup B$ \\ \hline
        Concatenation & $AB$ \\ \hline
        Kleene closure & $A*$ \\ \hline
    \end{tabular}
\end{center}

\subsection*{Deterministic Finite Automata}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $Q$ & States \\ \hline
        $\Sigma$ & Alphabet \\ \hline
        $\delta : Q \times \Sigma \rightarrow Q$ & Transition function \\ \hline
        $q \in Q$ & Start state \\ \hline
        $F \subseteq Q$ & Accept states \\ \hline
        $M = (Q, \Sigma, \delta, q, F)$ & Automaton \\ \hline
    \end{tabular}
\end{center}

\subsection*{Nondeterministic Finite Automata}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $Q$ & States \\ \hline
        $\Sigma$ & Alphabet \\ \hline
        $\delta : Q \times \Sigma_\epsilon \rightarrow \mathcal{P}(Q)$ & Transition function \\ \hline
        $q \in Q$ & Start state \\ \hline
        $F \subseteq Q$ & Accept states \\ \hline
        $M = (Q, \Sigma, \delta, q, F)$ & Automaton \\ \hline
    \end{tabular}
\end{center}

These are similiar to deterministic finite automata, with the following differences:
\begin{enumerate}
    \item They can sporadically transition on $\epsilon$
    \item They may transition on a symbol in multiple ways
    \item They may not transition on a symbol at all
\end{enumerate}
If any legal series of transitions lands on an accept state, the string is accepted. The transition table includes $\epsilon$ as a character to transition on, and the destination is a set of possible states. If the destination is the null set, the string is rejected by that branch.

\subsection*{Pumping lemma}
\begin{enumerate}
    \item $|y| \geq 1$
    \item $|xy| \leq p$
    \item $\forall i \in \mathbb{N}_0, \ xy^iz \in L$
\end{enumerate}
Note that $y$ must be in the first $p$ characters of the choice of $w$.

\section*{Context-Free}

\subsection*{Grammars}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $V$ & Variables \\ \hline
        $\Sigma$ & Terminals \\ \hline
        $S \in V$ & Start variable \\ \hline
        $R : V \rightarrow (V \cup \Sigma)*$ & Rules \\ \hline
        $G = (V, \Sigma, R, S)$ & Grammar \\ \hline
    \end{tabular}
\end{center}

\subsection*{Deterministic Pushdown Automata}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $\Sigma$ & Tape alphabet \\ \hline
        $\Gamma$ & Stack alphabet \\ \hline
        $Q$ & States \\ \hline
        $q \in Q$ & Start state \\ \hline
        $\delta : Q \times (\Sigma \cup \curly{\square}) \times \Gamma \rightarrow Q \times \curly{N, R} \times \Gamma*$ & Transition function \\ \hline
        $M = (\Sigma, \Gamma, Q, \delta, q)$ & Automaton \\ \hline
    \end{tabular}
\end{center}
The stack starts off as \$. At each step, the tape head is read and the top of the stack is popped off. These are passed along with the current state to the transition function, which will take the following actions:
\begin{enumerate}
    \item Move the tape head right or stay put
    \item Push any number of stack alphabet characters onto the stack
    \item Choose a new state
\end{enumerate}
The automaton terminates when the stack is empty. The string is accepted it if the automaton terminates on the blank character $\square$ immediately following the string.

\subsection*{Nondeterministic Pushdown Automata}

\section*{Decidable}

% Todo: Intuitions for language types

\end{document}