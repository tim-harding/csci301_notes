\documentclass[12pt]{article}

\usepackage{fouriernc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage[margin=1in]{geometry}

\newcommand{\curly}[1]{\left\{ #1 \right\}}
\newcommand{\round}[1]{\left( #1 \right)}
\newcommand{\hard}[1]{\left[ #1 \right]}
\newcommand{\C}[2]{
    \begin{pmatrix}
        #1 \\ #2
    \end{pmatrix}
}

\title{Theory of Computing Notes}
\author{Tim Harding}

\begin{document}

\section*{General}

\begin{center}
    \begin{tabular}{|l|l|l|}
        \hline
        Regular & Finite automaton & Regular expressions \\ \hline
        Context-Free & Pushdown automaton & Grammar \\ \hline
        Decidable & Turing machine & Code \\ \hline
    \end{tabular}
\end{center}

As a useful intuition for each language class:
\begin{enumerate}
    \item Default to regular
    \item If the language requires counting to some non-prespecified number, it bumps up to context-free.
    \item If the language requires relative counts of nonadjacent elements or more than two adjacent elements, it bumps up to decidable. Context-free languages can only perform addition and subtraction.
\end{enumerate}

\section*{Regular}
Finite automata can be expressed the following ways:
\begin{enumerate}
    \item A transition table, with states on one axis and alphabet characters on the other
    \item A graph with states as nodes, transitions on alphabet characters as edges, and acceptance states specially demarcated
    \item A regular expression
\end{enumerate}

\subsection*{Regular Operations}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Union & $A \cup B$ \\ \hline
        Concatenation & $AB$ \\ \hline
        Kleene closure & $A*$ \\ \hline
    \end{tabular}
\end{center}
These languages are also closed under complement and intersection, where context-free languages are not.

\subsection*{Deterministic Finite Automata}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $Q$ & States \\ \hline
        $\Sigma$ & Alphabet \\ \hline
        $\delta : Q \times \Sigma \rightarrow Q$ & Transition function \\ \hline
        $q \in Q$ & Start state \\ \hline
        $F \subseteq Q$ & Accept states \\ \hline
        $M = (Q, \Sigma, \delta, q, F)$ & Automaton \\ \hline
    \end{tabular}
\end{center}

\subsection*{Nondeterministic Finite Automata}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $Q$ & States \\ \hline
        $\Sigma$ & Alphabet \\ \hline
        $\delta : Q \times \Sigma_\epsilon \rightarrow \mathcal{P}(Q)$ & Transition function \\ \hline
        $q \in Q$ & Start state \\ \hline
        $F \subseteq Q$ & Accept states \\ \hline
        $M = (Q, \Sigma, \delta, q, F)$ & Automaton \\ \hline
    \end{tabular}
\end{center}

These are similiar to deterministic finite automata, with the following differences:
\begin{enumerate}
    \item They can sporadically transition on $\epsilon$
    \item They may transition on a symbol in multiple ways
    \item They may not transition on a symbol at all
\end{enumerate}
If any legal series of transitions lands on an accept state, the string is accepted. The transition table includes $\epsilon$ as a character to transition on, and the destination is a set of possible states. If the destination is the null set, the string is rejected by that branch.

\subsection*{Pumping lemma}
\begin{enumerate}
    \item $|y| \geq 1$
    \item $|xy| \leq p$
    \item $\forall i \in \mathbb{N}_0, \ xy^iz \in L$
\end{enumerate}
Note that $y$ must be in the first $p$ characters of the choice of $w$.

\section*{Context-Free}
Context-free languages extend regular languages with a stack.

\subsection*{Grammars}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $V$ & Variables \\ \hline
        $\Sigma$ & Terminals \\ \hline
        $S \in V$ & Start variable \\ \hline
        $R : V \rightarrow (V \cup \Sigma)*$ & Rules \\ \hline
        $G = (V, \Sigma, R, S)$ & Grammar \\ \hline
    \end{tabular}
\end{center}

\subsection*{Pushdown Automata}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $\Sigma$ & Tape alphabet \\ \hline
        $\Gamma$ & Stack alphabet \\ \hline
        $Q$ & States \\ \hline
        $q \in Q$ & Start state \\ \hline
        $\delta : Q \times (\Sigma \cup \curly{\square}) \times \Gamma \rightarrow Q \times \curly{N, R} \times \Gamma*$ & Transition function \\ \hline
        $M = (\Sigma, \Gamma, Q, \delta, q)$ & Automaton \\ \hline
    \end{tabular}
\end{center}
The stack starts off as \$. At each step, the tape head is read and the top of the stack is popped off. These are passed along with the current state to the transition function, which will take the following actions:
\begin{enumerate}
    \item Move the tape head right or stay put
    \item Push any number of stack alphabet characters onto the stack
    \item Choose a new state
\end{enumerate}
The automaton terminates when the stack is empty. The string is accepted it if the automaton terminates on the blank character $\square$ immediately following the string.

\subsubsection*{Nondeterministic Pushdown Automata}
These are the same as their deterministic variants, except that the transition function signature changes to the following:
\begin{align*}
    \delta : Q \times (\Sigma \cup \curly{\square}) \times \Gamma \rightarrow \mathcal{P}_f(Q \times \curly{N,R} \times \Gamma*)
\end{align*}
If any possible branch accepts the string, the automaton accepts the string.

\subsection*{Pumping lemma}
\begin{enumerate}
    \item $|vy| \geq 1$
    \item $|vxy| \leq p$
    \item $\forall i \in \mathbb{N}_0, uv^ixy^iz \in L$
\end{enumerate}

\section*{Decidable}
Decidable languages extend context-free languages with a heap.

\subsection*{Turing Machine}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        $\Sigma$ & Input alphabet \\ \hline
        $\Gamma$ & Tape alphabet \\ \hline
        $Q$ & States \\ \hline
        $q \in Q$ & Start state \\ \hline
        $q_\text{accept} \in Q$ & Accept state \\ \hline
        $q_\text{reject} \in Q$ & Reject state \\ \hline
        $\delta : Q \times \Gamma^k \rightarrow Q \times \Gamma^k \times \curly{L, R, N}^k$ & Transition function \\ \hline
        $M = (\Sigma, \Gamma, Q, \delta, q, q_\text{accept}, q_\text{reject})$ & Turing machine \\ \hline
    \end{tabular}
\end{center}
The machine contains $k \in mathbb{N}$ tapes. The first tape contains the input string and begins with the read head at its leftmost position. The other tapes are filled with $\square$. At each step, the transition function takes the following actions in response to the current state and the symbols under the read heads:
\begin{enumerate}
    \item Write a new symbol at the read head of each tape
    \item Move each read head left, right, or not at all
    \item Transition to a new state
\end{enumerate}
The machine terminates when it enters either the $q_\text{accept}$ or the $q_\text{reject}$ state. A string is accepted if the machine terminates in the $q_\text{accept}$ state.

\subsection*{Halting Problem}
Define a machine $M$ that takes a program as input and halts if and only if its input program does not halt. Feeding $M$ to itself, $M$ must do the opposite of itself, a contradiction.

\end{document}